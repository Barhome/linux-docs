## Redirection

- Any input to the pc goes to processing phase in case of success we get outputs and incase of failure we get an error. ex: command `ls -l file22` ls is the input then a processing phase and in case of success we get the list of info about the file22 and in case of failure if the file doesn't exit we get an error.
- as a system admin sometimes we do things that we might need it later in our business requirements example: taking a back up for our database, we need to define the best time to take this backup in times where the load on the system is minmum like on friday morning. we will write a script that runs a command to take the backup on firday morning. this script is automatic and a lot of outputs for the commands in this script will show up so we need to see the errors and ouputs. so, we need to redirect the ouputs instead of showing them on the screen they are saved on a file that we can check on it later. This is what redirection all about to facilitate showing the outputs and the error logs saved on a file.
- we can represent the descriptor of the input with 0 and the ouput with 1 and the error with 2.these numbers are called descriptors.
- the default input is the keyboard and the default output is the screen and the default error is also the screen.
- if you want to redirect to input and output you don't have to define the descriptor for them. but if you want to redirect to error you have to define the descriptor for it.
- we can also represent the keyboard with 0< sign and the output with 1> and the error with the 2> note that 0 and 1 can be eleminated as the system expect input and output for the error you have to set 2> to redirect.
- run the command `ls 1> resault.txt` this command will create a file called resault.txt and the output of the command ls will be save in this file.
- run the command `ls 2> error.txt` this command will create a file called error.txt and the ouput of the comman are only the errors.
- run the command `ls -l file22 file2 > resault.txt 2> error.txt` to save the outputs in the resault.txt and the errors in the error.txt. if we rerun this command we note the the logs and outputs will be overwritten in resault.txt and error.txt as when we are seprating the outputs and errors in this command example this overwritten behavior happens so to avoid that add >> and 2>> like this `ls -l file22 and file2 >> resault.txt 2>> error.txt`.
- note that > one sign means overwrite and >> means append.
- use the command `ls file2 file22 >>resault.txt 2>>resault.txt` means put the output and append the error in the same file or `ls file2 file22 2&>>resault.txt` which means the same thing
- an example to change the behavior of the input process. in cat command as its function is to view the content of a file. we can use cat to put input in a file. the default input of cat is to take them from the file not from the keyboard. to make it take input from the keyboard and save them in the file. use the commant `cat <<EOT>> error.txt` << means take input till you write EOT then >> add the content to the content of error.txt.also when we write the command `cat <file2> error.txt` this means take the input from file2 and redirect the output and overwrite them to error.txt. in cat one single sign <> means take from a file and redirect to another and two signs <<>> means take input and append them till you get the word EOT inside of <<EOT>>
- use the command `file filename` to know the type of the file. in linux the extension of a file and name doesn't show its type as the type depends on the content of the file and any file has a signature in the header of the file that shows us its type.

- use the command `less filename` to view the file page by page and quit with q letter with no automatic exiting `more filename` is the same and when reaching the end of the file it exits automatically.
- | pipe sign takes the output of a command and makes it the input of another ex: run the command `ls -Rl / |less`
- if we want the oupt to be shown in the terminal in the screen and also to be save in a file use the command `ls | tee result.txt` the pipe will take the output and send it to tee and tee takes the input and diplay it to the screen and save it to the file result.txt.
- use -a to append without it tee will overwrite the content of result.txt `ls | tee -a result.txt`
- use the command `w` this command will show you who is logged in and how long is he logged in and how long
  the machine is up and the load average in last minute and in last 5 minutes and in last 15 minutes . the user who is logged in is root and from which tty (we talked about tty and we said that it is the terminal you can access when you have physical access which means you have a keyboard and monitor that are attached to the machine) so if you are connected remotely through ssh , telnet or terminal from graphical user interface this session is PTS type which stands for Pseudo terminal screen which emulates that you have physical access or console access but you are not in our case we are connected remotely and it shows you from with ip address and logging time and idle time and processer consumption.
  - use command `who` to get simple information about who is logging and from which screen as 0 screen means the the screen no. 1 and 1 screen means you the screen no.2 , a server can be attached to many screens.
  - use the command `whoami` to get the user name
  - use the command `whatis commandName` to know about a command
  - use the command `whereis commandName` to know about where is the binary of this command , these previous command are called wh commands.
  - use the command `last` to list the last logged in users and their status all loggings.
  - use the command `lastlog` to list the last logging for all users only last logging. note that you will get a user named gdm gnoume display manger don't panic this is the graphical user interface.
  - note that these logging info comes from the binary file /var/log/wtmp .
